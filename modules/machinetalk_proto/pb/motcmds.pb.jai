// Code generated by protoc-gen-jai

#import "proto";
#import "Basic";
#import "Deep_Copy";


MotionType :: enum s32 {
    _EMC_MOTION_TYPE_NONE :: 0;
    _EMC_MOTION_TYPE_TRAVERSE :: 1;
    _EMC_MOTION_TYPE_FEED :: 2;
    _EMC_MOTION_TYPE_ARC :: 3;
    _EMC_MOTION_TYPE_TOOLCHANGE :: 4;
    _EMC_MOTION_TYPE_PROBING :: 5;
    _EMC_MOTION_TYPE_INDEXROTARY :: 6;
};

cmd_code_t :: enum s32 {
    EMCMOT_ABORT :: 4000;
    EMCMOT_AXIS_ABORT :: 4001;
    EMCMOT_ENABLE :: 4002;
    EMCMOT_DISABLE :: 4003;
    EMCMOT_ENABLE_AMPLIFIER :: 4004;
    EMCMOT_DISABLE_AMPLIFIER :: 4005;
    EMCMOT_ENABLE_WATCHDOG :: 4006;
    EMCMOT_DISABLE_WATCHDOG :: 4007;
    EMCMOT_ACTIVATE_JOINT :: 4008;
    EMCMOT_DEACTIVATE_JOINT :: 4009;
    EMCMOT_PAUSE :: 4010;
    EMCMOT_RESUME :: 4011;
    EMCMOT_STEP :: 4012;
    EMCMOT_FREE :: 4013;
    EMCMOT_COORD :: 4014;
    EMCMOT_TELEOP :: 4015;
    EMCMOT_SPINDLE_SCALE :: 4016;
    EMCMOT_SS_ENABLE :: 4017;
    EMCMOT_FEED_SCALE :: 4018;
    EMCMOT_FS_ENABLE :: 4019;
    EMCMOT_FH_ENABLE :: 4020;
    EMCMOT_AF_ENABLE :: 4021;
    EMCMOT_OVERRIDE_LIMITS :: 4022;
    EMCMOT_HOME :: 4023;
    EMCMOT_UNHOME :: 4024;
    EMCMOT_JOG_CONT :: 4025;
    EMCMOT_JOG_INCR :: 4026;
    EMCMOT_JOG_ABS :: 4027;
    EMCMOT_SET_LINE :: 4028;
    EMCMOT_SET_CIRCLE :: 4029;
    EMCMOT_SET_TELEOP_VECTOR :: 4030;
    EMCMOT_CLEAR_PROBE_FLAGS :: 4031;
    EMCMOT_PROBE :: 4032;
    EMCMOT_RIGID_TAP :: 4033;
    EMCMOT_SET_POSITION_LIMITS :: 4034;
    EMCMOT_SET_BACKLASH :: 4035;
    EMCMOT_SET_MIN_FERROR :: 4036;
    EMCMOT_SET_MAX_FERROR :: 4037;
    EMCMOT_SET_VEL :: 4038;
    EMCMOT_SET_VEL_LIMIT :: 4039;
    EMCMOT_SET_JOINT_VEL_LIMIT :: 4040;
    EMCMOT_SET_JOINT_ACC_LIMIT :: 4041;
    EMCMOT_SET_ACC :: 4042;
    EMCMOT_SET_TERM_COND :: 4043;
    EMCMOT_SET_NUM_AXES :: 4044;
    EMCMOT_SET_WORLD_HOME :: 4045;
    EMCMOT_SET_HOMING_PARAMS :: 4046;
    EMCMOT_SET_DEBUG :: 4047;
    EMCMOT_SET_DOUT :: 4048;
    EMCMOT_SET_AOUT :: 4049;
    EMCMOT_SET_SPINDLESYNC :: 4050;
    EMCMOT_SPINDLE_ON :: 4051;
    EMCMOT_SPINDLE_OFF :: 4052;
    EMCMOT_SPINDLE_INCREASE :: 4053;
    EMCMOT_SPINDLE_DECREASE :: 4054;
    EMCMOT_SPINDLE_BRAKE_ENGAGE :: 4055;
    EMCMOT_SPINDLE_BRAKE_RELEASE :: 4056;
    EMCMOT_SET_MOTOR_OFFSET :: 4057;
    EMCMOT_SET_JOINT_COMP :: 4058;
    EMCMOT_SET_OFFSET :: 4059;
};

cmd_status_t :: enum s32 {
    EMCMOT_COMMAND_OK :: 0;
    EMCMOT_COMMAND_UNKNOWN_COMMAND :: 1;
    EMCMOT_COMMAND_INVALID_COMMAND :: 2;
    EMCMOT_COMMAND_INVALID_PARAMS :: 3;
    EMCMOT_COMMAND_BAD_EXEC :: 4;
};
MotionCommand :: struct {
    command: cmd_code_t;
    commandNum: u32;
    motor_offset: *float64;
    maxLimit: *float64;
    minLimit: *float64;
    pos: *EmcPose;
    center: *PmCartesian;
    normal: *PmCartesian;
    turn: *u32;
    vel: *float64;
    ini_maxvel: *float64;
    motion_type: *MotionType;
    spindlesync: *float64;
    acc: *float64;
    backlash: *float64;
    id: *u32;
    termCond: *u32;
    tolerance: *float64;
    axis: *u32;
    scale: *float64;
    offset: *float64;
    home: *float64;
    home_final_vel: *float64;
    search_vel: *float64;
    latch_vel: *float64;
    flags: *u32;
    home_sequence: *u32;
    volatile_home: *u32;
    minFerror: *float64;
    maxFerror: *float64;
    wdWait: *u32;
    debug: *u32;
    now: *s32;
    out: *s32;
    start: *s32;
    end: *s32;
    mode: *s32;
    comp_nominal: *float64;
    comp_forward: *float64;
    comp_reverse: *float64;
    probe_type: *s32;
    tool_offset: *EmcPose;

    _desc_table :: struct {
        command := FieldDesc.{tag=10, type=type_of(cmd_code_t), optional=false, repeated=false, wt=.Varint};
        commandNum := FieldDesc.{tag=20, type=type_of(u32), optional=false, repeated=false, wt=.Fixed32};
        motor_offset := FieldDesc.{tag=30, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        maxLimit := FieldDesc.{tag=40, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        minLimit := FieldDesc.{tag=50, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        pos := FieldDesc.{tag=60, type=type_of(EmcPose), optional=true, repeated=false, wt=.Size};
        center := FieldDesc.{tag=70, type=type_of(PmCartesian), optional=true, repeated=false, wt=.Size};
        normal := FieldDesc.{tag=80, type=type_of(PmCartesian), optional=true, repeated=false, wt=.Size};
        turn := FieldDesc.{tag=90, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        vel := FieldDesc.{tag=100, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        ini_maxvel := FieldDesc.{tag=110, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        motion_type := FieldDesc.{tag=120, type=type_of(MotionType), optional=true, repeated=false, wt=.Varint};
        spindlesync := FieldDesc.{tag=130, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        acc := FieldDesc.{tag=140, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        backlash := FieldDesc.{tag=150, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        id := FieldDesc.{tag=160, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        termCond := FieldDesc.{tag=170, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        tolerance := FieldDesc.{tag=180, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        axis := FieldDesc.{tag=190, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        scale := FieldDesc.{tag=200, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        offset := FieldDesc.{tag=210, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        home := FieldDesc.{tag=220, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        home_final_vel := FieldDesc.{tag=230, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        search_vel := FieldDesc.{tag=240, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        latch_vel := FieldDesc.{tag=250, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        flags := FieldDesc.{tag=260, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        home_sequence := FieldDesc.{tag=270, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        volatile_home := FieldDesc.{tag=280, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        minFerror := FieldDesc.{tag=290, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        maxFerror := FieldDesc.{tag=300, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        wdWait := FieldDesc.{tag=310, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        debug := FieldDesc.{tag=320, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        now := FieldDesc.{tag=330, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        out := FieldDesc.{tag=340, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        start := FieldDesc.{tag=350, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        end := FieldDesc.{tag=360, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        mode := FieldDesc.{tag=370, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        comp_nominal := FieldDesc.{tag=380, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        comp_forward := FieldDesc.{tag=390, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        comp_reverse := FieldDesc.{tag=400, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        probe_type := FieldDesc.{tag=410, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        tool_offset := FieldDesc.{tag=420, type=type_of(EmcPose), optional=true, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: MotionCommand) {
        #insert #run encode_code_writer(MotionCommand.{});
    }

    decode :: (b: []u8) -> MotionCommand {
        #insert #run decode_code_writer(MotionCommand.{});
    }

};
#insert #run setters_code_writer(MotionCommand.{});
MotionStatus :: struct {
    commandEcho: cmd_code_t;
    commandNumEcho: u32;
    commandStatus: cmd_status_t;
    carte_pos_fb: *EmcPose;

    _desc_table :: struct {
        commandEcho := FieldDesc.{tag=10, type=type_of(cmd_code_t), optional=false, repeated=false, wt=.Varint};
        commandNumEcho := FieldDesc.{tag=20, type=type_of(u32), optional=false, repeated=false, wt=.Fixed32};
        commandStatus := FieldDesc.{tag=30, type=type_of(cmd_status_t), optional=false, repeated=false, wt=.Varint};
        carte_pos_fb := FieldDesc.{tag=40, type=type_of(EmcPose), optional=true, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: MotionStatus) {
        #insert #run encode_code_writer(MotionStatus.{});
    }

    decode :: (b: []u8) -> MotionStatus {
        #insert #run decode_code_writer(MotionStatus.{});
    }

};
#insert #run setters_code_writer(MotionStatus.{});
