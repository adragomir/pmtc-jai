// Code generated by protoc-gen-jai

#import "proto";
#import "Basic";
#import "Deep_Copy";


EmcTaskExecStateType :: enum s32 {
    EMC_TASK_EXEC_ERROR :: 1;
    EMC_TASK_EXEC_DONE :: 2;
    EMC_TASK_EXEC_WAITING_FOR_MOTION :: 3;
    EMC_TASK_EXEC_WAITING_FOR_MOTION_QUEUE :: 4;
    EMC_TASK_EXEC_WAITING_FOR_IO :: 5;
    EMC_TASK_EXEC_WAITING_FOR_MOTION_AND_IO :: 7;
    EMC_TASK_EXEC_WAITING_FOR_DELAY :: 8;
    EMC_TASK_EXEC_WAITING_FOR_SYSTEM_CMD :: 9;
    EMC_TASK_EXEC_WAITING_FOR_SPINDLE_ORIENTED :: 10;
};

EmcInterpStateType :: enum s32 {
    EMC_TASK_INTERP_IDLE :: 1;
    EMC_TASK_INTERP_READING :: 2;
    EMC_TASK_INTERP_PAUSED :: 3;
    EMC_TASK_INTERP_WAITING :: 4;
    EMC_TASK_INTERP_SEEKING :: 5;
};

EmcInterpExitCodeType :: enum s32 {
    EMC_INTERP_EXIT_OK :: 0;
    EMC_INTERP_EXIT_EXIT :: 1;
    EMC_INTERP_EXIT_EXECUTE_FINISH :: 2;
    EMC_INTERP_EXIT_ENDFILE :: 3;
    EMC_INTERP_EXIT_FILE_NOT_OPEN :: 4;
    EMC_INTERP_EXIT_ERROR :: 5;
};

EmcKinematicsType :: enum s32 {
    KINEMATICS_IDENTITY :: 1;
    KINEMATICS_FORWARD_ONLY :: 2;
    KINEMATICS_INVERSE_ONLY :: 3;
    KINEMATICS_BOTH :: 4;
};

EmcTrajectoryModeType :: enum s32 {
    EMC_TRAJ_MODE_FREE :: 1;
    EMC_TRAJ_MODE_COORD :: 2;
    EMC_TRAJ_MODE_TELEOP :: 3;
};

EmcCanonUnitsType :: enum s32 {
    CANON_UNITS_INCH :: 1;
    CANON_UNITS_MM :: 2;
    CANON_UNITS_CM :: 3;
};

EmcLinearUnitsType :: enum s32 {
    LINEAR_UNITS_INCH :: 1;
    LINEAR_UNITS_MM :: 2;
    LINEAR_UNITS_CM :: 3;
};

EmcAngularUnitsType :: enum s32 {
    ANGULAR_UNITS_DEGREES :: 1;
    ANGULAR_UNITS_RADIAN :: 2;
    ANGULAR_UNITS_GRAD :: 3;
};

EmcTimeUnitsType :: enum s32 {
    TIME_UNITS_MINUTE :: 1;
    TIME_UNITS_SECOND :: 2;
};

EmcTaskModeType :: enum s32 {
    EMC_TASK_MODE_MANUAL :: 1;
    EMC_TASK_MODE_AUTO :: 2;
    EMC_TASK_MODE_MDI :: 3;
};

EmcTaskStateType :: enum s32 {
    EMC_TASK_STATE_ESTOP :: 1;
    EMC_TASK_STATE_ESTOP_RESET :: 2;
    EMC_TASK_STATE_OFF :: 3;
    EMC_TASK_STATE_ON :: 4;
};

EmcAxisType :: enum s32 {
    EMC_AXIS_LINEAR :: 1;
    EMC_AXIS_ANGULAR :: 2;
};

EmcPositionOffsetType :: enum s32 {
    EMC_CONFIG_RELATIVE_OFFSET :: 1;
    EMC_CONFIG_MACHINE_OFFSET :: 2;
};

EmcPositionFeedbackType :: enum s32 {
    EMC_CONFIG_ACTUAL_FEEDBACK :: 1;
    EMC_CONFIG_COMMANDED_FEEDBACK :: 2;
};
EmcToolData :: struct {
    index: s32;
    id: *s32;
    diameter: *float64;
    frontangle: *float64;
    backangle: *float64;
    orientation: *s32;
    offset: *Position;
    comment: *string;
    pocket: *s32;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        id := FieldDesc.{tag=2, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        diameter := FieldDesc.{tag=12, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        frontangle := FieldDesc.{tag=13, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        backangle := FieldDesc.{tag=14, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        orientation := FieldDesc.{tag=15, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        offset := FieldDesc.{tag=16, type=type_of(Position), optional=true, repeated=false, wt=.Size};
        comment := FieldDesc.{tag=17, type=type_of(string), optional=true, repeated=false, wt=.Size};
        pocket := FieldDesc.{tag=18, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: EmcToolData) {
        #insert #run encode_code_writer(EmcToolData.{});
    }

    decode :: (b: []u8) -> EmcToolData {
        #insert #run decode_code_writer(EmcToolData.{});
    }

};
#insert #run setters_code_writer(EmcToolData.{});
EmcStatusMotionAxis :: struct {
    index: s32;
    enabled: *bool;
    fault: *bool;
    ferror_current: *float64;
    ferror_highmark: *float64;
    homed: *bool;
    homing: *bool;
    inpos: *bool;
    input: *float64;
    max_hard_limit: *bool;
    max_soft_limit: *bool;
    min_hard_limit: *bool;
    min_soft_limit: *bool;
    output: *float64;
    override_limits: *bool;
    velocity: *float64;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        enabled := FieldDesc.{tag=2, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        fault := FieldDesc.{tag=3, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        ferror_current := FieldDesc.{tag=4, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        ferror_highmark := FieldDesc.{tag=5, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        homed := FieldDesc.{tag=6, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        homing := FieldDesc.{tag=7, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        inpos := FieldDesc.{tag=8, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        input := FieldDesc.{tag=9, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        max_hard_limit := FieldDesc.{tag=10, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        max_soft_limit := FieldDesc.{tag=11, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        min_hard_limit := FieldDesc.{tag=12, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        min_soft_limit := FieldDesc.{tag=13, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        output := FieldDesc.{tag=14, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        override_limits := FieldDesc.{tag=15, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        velocity := FieldDesc.{tag=16, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: EmcStatusMotionAxis) {
        #insert #run encode_code_writer(EmcStatusMotionAxis.{});
    }

    decode :: (b: []u8) -> EmcStatusMotionAxis {
        #insert #run decode_code_writer(EmcStatusMotionAxis.{});
    }

};
#insert #run setters_code_writer(EmcStatusMotionAxis.{});
EmcStatusConfigAxis :: struct {
    index: s32;
    axis_type: *EmcAxisType;
    backlash: *float64;
    max_ferror: *float64;
    max_position_limit: *float64;
    min_ferror: *float64;
    min_position_limit: *float64;
    home_sequence: *s32;
    max_acceleration: *float64;
    max_velocity: *float64;
    increments: *string;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        axis_type := FieldDesc.{tag=2, type=type_of(EmcAxisType), optional=true, repeated=false, wt=.Varint};
        backlash := FieldDesc.{tag=3, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        max_ferror := FieldDesc.{tag=4, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        max_position_limit := FieldDesc.{tag=5, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        min_ferror := FieldDesc.{tag=6, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        min_position_limit := FieldDesc.{tag=7, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        home_sequence := FieldDesc.{tag=9, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        max_acceleration := FieldDesc.{tag=10, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        max_velocity := FieldDesc.{tag=11, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        increments := FieldDesc.{tag=12, type=type_of(string), optional=true, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: EmcStatusConfigAxis) {
        #insert #run encode_code_writer(EmcStatusConfigAxis.{});
    }

    decode :: (b: []u8) -> EmcStatusConfigAxis {
        #insert #run decode_code_writer(EmcStatusConfigAxis.{});
    }

};
#insert #run setters_code_writer(EmcStatusConfigAxis.{});
EmcProgramExtension :: struct {
    index: s32;
    extension: *string;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        extension := FieldDesc.{tag=2, type=type_of(string), optional=true, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: EmcProgramExtension) {
        #insert #run encode_code_writer(EmcProgramExtension.{});
    }

    decode :: (b: []u8) -> EmcProgramExtension {
        #insert #run decode_code_writer(EmcProgramExtension.{});
    }

};
#insert #run setters_code_writer(EmcProgramExtension.{});
EmcStatusAnalogIO :: struct {
    index: s32;
    value: *float64;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        value := FieldDesc.{tag=2, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: EmcStatusAnalogIO) {
        #insert #run encode_code_writer(EmcStatusAnalogIO.{});
    }

    decode :: (b: []u8) -> EmcStatusAnalogIO {
        #insert #run decode_code_writer(EmcStatusAnalogIO.{});
    }

};
#insert #run setters_code_writer(EmcStatusAnalogIO.{});
EmcStatusDigitalIO :: struct {
    index: s32;
    value: *bool;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        value := FieldDesc.{tag=2, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: EmcStatusDigitalIO) {
        #insert #run encode_code_writer(EmcStatusDigitalIO.{});
    }

    decode :: (b: []u8) -> EmcStatusDigitalIO {
        #insert #run decode_code_writer(EmcStatusDigitalIO.{});
    }

};
#insert #run setters_code_writer(EmcStatusDigitalIO.{});
EmcStatusLimit :: struct {
    index: s32;
    value: *s32;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        value := FieldDesc.{tag=2, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: EmcStatusLimit) {
        #insert #run encode_code_writer(EmcStatusLimit.{});
    }

    decode :: (b: []u8) -> EmcStatusLimit {
        #insert #run decode_code_writer(EmcStatusLimit.{});
    }

};
#insert #run setters_code_writer(EmcStatusLimit.{});
EmcStatusGCode :: struct {
    index: s32;
    value: *s32;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        value := FieldDesc.{tag=2, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: EmcStatusGCode) {
        #insert #run encode_code_writer(EmcStatusGCode.{});
    }

    decode :: (b: []u8) -> EmcStatusGCode {
        #insert #run decode_code_writer(EmcStatusGCode.{});
    }

};
#insert #run setters_code_writer(EmcStatusGCode.{});
EmcStatusMCode :: struct {
    index: s32;
    value: *s32;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        value := FieldDesc.{tag=2, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: EmcStatusMCode) {
        #insert #run encode_code_writer(EmcStatusMCode.{});
    }

    decode :: (b: []u8) -> EmcStatusMCode {
        #insert #run decode_code_writer(EmcStatusMCode.{});
    }

};
#insert #run setters_code_writer(EmcStatusMCode.{});
EmcStatusSetting :: struct {
    index: s32;
    value: *float64;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        value := FieldDesc.{tag=2, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: EmcStatusSetting) {
        #insert #run encode_code_writer(EmcStatusSetting.{});
    }

    decode :: (b: []u8) -> EmcStatusSetting {
        #insert #run decode_code_writer(EmcStatusSetting.{});
    }

};
#insert #run setters_code_writer(EmcStatusSetting.{});
EmcStatusConfig :: struct {
    default_acceleration: *float64;
    axes: *s32;
    axis: [..]EmcStatusConfigAxis;
    axis_mask: *s32;
    cycle_time: *float64;
    debug: *s32;
    kinematics_type: *EmcKinematicsType;
    max_acceleration: *float64;
    max_velocity: *float64;
    linear_units: *EmcLinearUnitsType;
    default_velocity: *float64;
    program_extension: [..]EmcProgramExtension;
    position_offset: *EmcPositionOffsetType;
    position_feedback: *EmcPositionFeedbackType;
    max_feed_override: *float64;
    min_feed_override: *float64;
    max_spindle_override: *float64;
    min_spindle_override: *float64;
    default_spindle_speed: *float64;
    default_linear_velocity: *float64;
    min_velocity: *float64;
    max_linear_velocity: *float64;
    min_linear_velocity: *float64;
    default_angular_velocity: *float64;
    max_angular_velocity: *float64;
    min_angular_velocity: *float64;
    increments: *string;
    grids: *string;
    lathe: *bool;
    geometry: *string;
    arcdivision: *u32;
    no_force_homing: *bool;
    remote_path: *string;
    time_units: *EmcTimeUnitsType;
    name: *string;
    user_command: [..]EmcStatusUserCommand;
    angular_units: *EmcAngularUnitsType;

    _desc_table :: struct {
        default_acceleration := FieldDesc.{tag=1, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        axes := FieldDesc.{tag=3, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        axis := FieldDesc.{tag=4, type=type_of(EmcStatusConfigAxis), optional=false, repeated=true, wt=.Size};
        axis_mask := FieldDesc.{tag=5, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        cycle_time := FieldDesc.{tag=6, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        debug := FieldDesc.{tag=7, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        kinematics_type := FieldDesc.{tag=8, type=type_of(EmcKinematicsType), optional=true, repeated=false, wt=.Varint};
        max_acceleration := FieldDesc.{tag=10, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        max_velocity := FieldDesc.{tag=11, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        linear_units := FieldDesc.{tag=12, type=type_of(EmcLinearUnitsType), optional=true, repeated=false, wt=.Varint};
        default_velocity := FieldDesc.{tag=13, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        program_extension := FieldDesc.{tag=14, type=type_of(EmcProgramExtension), optional=false, repeated=true, wt=.Size};
        position_offset := FieldDesc.{tag=15, type=type_of(EmcPositionOffsetType), optional=true, repeated=false, wt=.Varint};
        position_feedback := FieldDesc.{tag=16, type=type_of(EmcPositionFeedbackType), optional=true, repeated=false, wt=.Varint};
        max_feed_override := FieldDesc.{tag=17, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        min_feed_override := FieldDesc.{tag=18, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        max_spindle_override := FieldDesc.{tag=19, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        min_spindle_override := FieldDesc.{tag=20, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        default_spindle_speed := FieldDesc.{tag=21, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        default_linear_velocity := FieldDesc.{tag=22, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        min_velocity := FieldDesc.{tag=23, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        max_linear_velocity := FieldDesc.{tag=24, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        min_linear_velocity := FieldDesc.{tag=25, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        default_angular_velocity := FieldDesc.{tag=26, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        max_angular_velocity := FieldDesc.{tag=27, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        min_angular_velocity := FieldDesc.{tag=28, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        increments := FieldDesc.{tag=29, type=type_of(string), optional=true, repeated=false, wt=.Size};
        grids := FieldDesc.{tag=30, type=type_of(string), optional=true, repeated=false, wt=.Size};
        lathe := FieldDesc.{tag=31, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        geometry := FieldDesc.{tag=32, type=type_of(string), optional=true, repeated=false, wt=.Size};
        arcdivision := FieldDesc.{tag=33, type=type_of(u32), optional=true, repeated=false, wt=.Varint};
        no_force_homing := FieldDesc.{tag=34, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        remote_path := FieldDesc.{tag=35, type=type_of(string), optional=true, repeated=false, wt=.Size};
        time_units := FieldDesc.{tag=36, type=type_of(EmcTimeUnitsType), optional=true, repeated=false, wt=.Varint};
        name := FieldDesc.{tag=37, type=type_of(string), optional=true, repeated=false, wt=.Size};
        user_command := FieldDesc.{tag=38, type=type_of(EmcStatusUserCommand), optional=false, repeated=true, wt=.Size};
        angular_units := FieldDesc.{tag=39, type=type_of(EmcAngularUnitsType), optional=true, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: EmcStatusConfig) {
        #insert #run encode_code_writer(EmcStatusConfig.{});
    }

    decode :: (b: []u8) -> EmcStatusConfig {
        #insert #run decode_code_writer(EmcStatusConfig.{});
    }

};
#insert #run setters_code_writer(EmcStatusConfig.{});
EmcStatusMotion :: struct {
    active_queue: *s32;
    actual_position: *Position;
    adaptive_feed_enabled: *bool;
    ain: [..]EmcStatusAnalogIO;
    aout: [..]EmcStatusAnalogIO;
    axis: [..]EmcStatusMotionAxis;
    block_delete: *bool;
    current_line: *s32;
    current_vel: *float64;
    delay_left: *float64;
    din: [..]EmcStatusDigitalIO;
    distance_to_go: *float64;
    dout: [..]EmcStatusDigitalIO;
    dtg: *Position;
    enabled: *bool;
    feed_hold_enabled: *bool;
    feed_override_enabled: *bool;
    feedrate: *float64;
    g5x_index: *OriginIndex;
    g5x_offset: *Position;
    g92_offset: *Position;
    id: *s32;
    inpos: *bool;
    joint_actual_position: *Position;
    joint_position: *Position;
    limit: [..]EmcStatusLimit;
    motion_line: *s32;
    motion_type: *MotionType;
    motion_mode: *EmcTrajectoryModeType;
    paused: *bool;
    position: *Position;
    probe_tripped: *bool;
    probe_val: *s32;
    probed_position: *Position;
    probing: *bool;
    queue: *s32;
    queue_full: *bool;
    rotation_xy: *float64;
    spindle_brake: *bool;
    spindle_direction: *s32;
    spindle_enabled: *bool;
    spindle_increasing: *s32;
    spindle_override_enabled: *bool;
    spindle_speed: *float64;
    spindlerate: *float64;
    state: *RCS_STATUS;
    max_velocity: *float64;
    max_acceleration: *float64;
    rapidrate: *float64;

    _desc_table :: struct {
        active_queue := FieldDesc.{tag=1, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        actual_position := FieldDesc.{tag=2, type=type_of(Position), optional=true, repeated=false, wt=.Size};
        adaptive_feed_enabled := FieldDesc.{tag=3, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        ain := FieldDesc.{tag=4, type=type_of(EmcStatusAnalogIO), optional=false, repeated=true, wt=.Size};
        aout := FieldDesc.{tag=5, type=type_of(EmcStatusAnalogIO), optional=false, repeated=true, wt=.Size};
        axis := FieldDesc.{tag=6, type=type_of(EmcStatusMotionAxis), optional=false, repeated=true, wt=.Size};
        block_delete := FieldDesc.{tag=7, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        current_line := FieldDesc.{tag=8, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        current_vel := FieldDesc.{tag=9, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        delay_left := FieldDesc.{tag=10, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        din := FieldDesc.{tag=11, type=type_of(EmcStatusDigitalIO), optional=false, repeated=true, wt=.Size};
        distance_to_go := FieldDesc.{tag=12, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        dout := FieldDesc.{tag=13, type=type_of(EmcStatusDigitalIO), optional=false, repeated=true, wt=.Size};
        dtg := FieldDesc.{tag=14, type=type_of(Position), optional=true, repeated=false, wt=.Size};
        enabled := FieldDesc.{tag=15, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        feed_hold_enabled := FieldDesc.{tag=16, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        feed_override_enabled := FieldDesc.{tag=17, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        feedrate := FieldDesc.{tag=18, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        g5x_index := FieldDesc.{tag=19, type=type_of(OriginIndex), optional=true, repeated=false, wt=.Varint};
        g5x_offset := FieldDesc.{tag=20, type=type_of(Position), optional=true, repeated=false, wt=.Size};
        g92_offset := FieldDesc.{tag=21, type=type_of(Position), optional=true, repeated=false, wt=.Size};
        id := FieldDesc.{tag=23, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        inpos := FieldDesc.{tag=24, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        joint_actual_position := FieldDesc.{tag=25, type=type_of(Position), optional=true, repeated=false, wt=.Size};
        joint_position := FieldDesc.{tag=26, type=type_of(Position), optional=true, repeated=false, wt=.Size};
        limit := FieldDesc.{tag=27, type=type_of(EmcStatusLimit), optional=false, repeated=true, wt=.Size};
        motion_line := FieldDesc.{tag=28, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        motion_type := FieldDesc.{tag=29, type=type_of(MotionType), optional=true, repeated=false, wt=.Varint};
        motion_mode := FieldDesc.{tag=30, type=type_of(EmcTrajectoryModeType), optional=true, repeated=false, wt=.Varint};
        paused := FieldDesc.{tag=31, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        position := FieldDesc.{tag=32, type=type_of(Position), optional=true, repeated=false, wt=.Size};
        probe_tripped := FieldDesc.{tag=33, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        probe_val := FieldDesc.{tag=34, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        probed_position := FieldDesc.{tag=35, type=type_of(Position), optional=true, repeated=false, wt=.Size};
        probing := FieldDesc.{tag=36, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        queue := FieldDesc.{tag=37, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        queue_full := FieldDesc.{tag=38, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        rotation_xy := FieldDesc.{tag=39, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        spindle_brake := FieldDesc.{tag=40, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        spindle_direction := FieldDesc.{tag=41, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        spindle_enabled := FieldDesc.{tag=42, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        spindle_increasing := FieldDesc.{tag=43, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        spindle_override_enabled := FieldDesc.{tag=44, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        spindle_speed := FieldDesc.{tag=45, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        spindlerate := FieldDesc.{tag=46, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        state := FieldDesc.{tag=47, type=type_of(RCS_STATUS), optional=true, repeated=false, wt=.Varint};
        max_velocity := FieldDesc.{tag=48, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        max_acceleration := FieldDesc.{tag=49, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        rapidrate := FieldDesc.{tag=50, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: EmcStatusMotion) {
        #insert #run encode_code_writer(EmcStatusMotion.{});
    }

    decode :: (b: []u8) -> EmcStatusMotion {
        #insert #run decode_code_writer(EmcStatusMotion.{});
    }

};
#insert #run setters_code_writer(EmcStatusMotion.{});
EmcStatusIo :: struct {
    estop: *bool;
    flood: *bool;
    lube: *bool;
    lube_level: *bool;
    mist: *bool;
    tool_offset: *Position;
    tool_table: [..]EmcToolData;
    pocket_prepped: *s32;
    tool_in_spindle: *s32;

    _desc_table :: struct {
        estop := FieldDesc.{tag=1, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        flood := FieldDesc.{tag=2, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        lube := FieldDesc.{tag=3, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        lube_level := FieldDesc.{tag=4, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        mist := FieldDesc.{tag=5, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        tool_offset := FieldDesc.{tag=8, type=type_of(Position), optional=true, repeated=false, wt=.Size};
        tool_table := FieldDesc.{tag=9, type=type_of(EmcToolData), optional=false, repeated=true, wt=.Size};
        pocket_prepped := FieldDesc.{tag=10, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        tool_in_spindle := FieldDesc.{tag=11, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: EmcStatusIo) {
        #insert #run encode_code_writer(EmcStatusIo.{});
    }

    decode :: (b: []u8) -> EmcStatusIo {
        #insert #run decode_code_writer(EmcStatusIo.{});
    }

};
#insert #run setters_code_writer(EmcStatusIo.{});
EmcStatusTask :: struct {
    echo_serial_number: *s32;
    exec_state: *EmcTaskExecStateType;
    file: *string;
    input_timeout: *bool;
    optional_stop: *bool;
    read_line: *s32;
    task_mode: *EmcTaskModeType;
    task_paused: *s32;
    task_state: *EmcTaskStateType;
    total_lines: *s32;

    _desc_table :: struct {
        echo_serial_number := FieldDesc.{tag=1, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        exec_state := FieldDesc.{tag=2, type=type_of(EmcTaskExecStateType), optional=true, repeated=false, wt=.Varint};
        file := FieldDesc.{tag=3, type=type_of(string), optional=true, repeated=false, wt=.Size};
        input_timeout := FieldDesc.{tag=4, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        optional_stop := FieldDesc.{tag=5, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        read_line := FieldDesc.{tag=6, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        task_mode := FieldDesc.{tag=7, type=type_of(EmcTaskModeType), optional=true, repeated=false, wt=.Varint};
        task_paused := FieldDesc.{tag=8, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        task_state := FieldDesc.{tag=9, type=type_of(EmcTaskStateType), optional=true, repeated=false, wt=.Varint};
        total_lines := FieldDesc.{tag=10, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: EmcStatusTask) {
        #insert #run encode_code_writer(EmcStatusTask.{});
    }

    decode :: (b: []u8) -> EmcStatusTask {
        #insert #run decode_code_writer(EmcStatusTask.{});
    }

};
#insert #run setters_code_writer(EmcStatusTask.{});
EmcStatusInterp :: struct {
    command: *string;
    gcodes: [..]EmcStatusGCode;
    interp_state: *EmcInterpStateType;
    interpreter_errcode: *EmcInterpExitCodeType;
    mcodes: [..]EmcStatusMCode;
    settings: [..]EmcStatusSetting;
    program_units: *EmcCanonUnitsType;

    _desc_table :: struct {
        command := FieldDesc.{tag=1, type=type_of(string), optional=true, repeated=false, wt=.Size};
        gcodes := FieldDesc.{tag=2, type=type_of(EmcStatusGCode), optional=false, repeated=true, wt=.Size};
        interp_state := FieldDesc.{tag=3, type=type_of(EmcInterpStateType), optional=true, repeated=false, wt=.Varint};
        interpreter_errcode := FieldDesc.{tag=4, type=type_of(EmcInterpExitCodeType), optional=true, repeated=false, wt=.Varint};
        mcodes := FieldDesc.{tag=5, type=type_of(EmcStatusMCode), optional=false, repeated=true, wt=.Size};
        settings := FieldDesc.{tag=6, type=type_of(EmcStatusSetting), optional=false, repeated=true, wt=.Size};
        program_units := FieldDesc.{tag=7, type=type_of(EmcCanonUnitsType), optional=true, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: EmcStatusInterp) {
        #insert #run encode_code_writer(EmcStatusInterp.{});
    }

    decode :: (b: []u8) -> EmcStatusInterp {
        #insert #run decode_code_writer(EmcStatusInterp.{});
    }

};
#insert #run setters_code_writer(EmcStatusInterp.{});
EmcCommandParameters :: struct {
    index: *u32;
    debug_level: *u32;
    line_number: *s32;
    scale: *float64;
    velocity: *float64;
    distance: *float64;
    value: *float64;
    enable: *bool;
    command: *string;
    path: *string;
    task_mode: *EmcTaskModeType;
    task_state: *EmcTaskStateType;
    traj_mode: *EmcTrajectoryModeType;
    pose: *EmcPose;
    tool_data: *EmcToolData;
    tool_table: [..]EmcToolData;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(u32), optional=true, repeated=false, wt=.Varint};
        debug_level := FieldDesc.{tag=2, type=type_of(u32), optional=true, repeated=false, wt=.Varint};
        line_number := FieldDesc.{tag=3, type=type_of(s32), optional=true, repeated=false, wt=.ZigZag};
        scale := FieldDesc.{tag=4, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        velocity := FieldDesc.{tag=5, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        distance := FieldDesc.{tag=6, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        value := FieldDesc.{tag=7, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        enable := FieldDesc.{tag=8, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        command := FieldDesc.{tag=9, type=type_of(string), optional=true, repeated=false, wt=.Size};
        path := FieldDesc.{tag=10, type=type_of(string), optional=true, repeated=false, wt=.Size};
        task_mode := FieldDesc.{tag=100, type=type_of(EmcTaskModeType), optional=true, repeated=false, wt=.Varint};
        task_state := FieldDesc.{tag=101, type=type_of(EmcTaskStateType), optional=true, repeated=false, wt=.Varint};
        traj_mode := FieldDesc.{tag=102, type=type_of(EmcTrajectoryModeType), optional=true, repeated=false, wt=.Varint};
        pose := FieldDesc.{tag=103, type=type_of(EmcPose), optional=true, repeated=false, wt=.Size};
        tool_data := FieldDesc.{tag=104, type=type_of(EmcToolData), optional=true, repeated=false, wt=.Size};
        tool_table := FieldDesc.{tag=105, type=type_of(EmcToolData), optional=false, repeated=true, wt=.Size};
    };

    encode :: (b: *[..]u8, self: EmcCommandParameters) {
        #insert #run encode_code_writer(EmcCommandParameters.{});
    }

    decode :: (b: []u8) -> EmcCommandParameters {
        #insert #run decode_code_writer(EmcCommandParameters.{});
    }

};
#insert #run setters_code_writer(EmcCommandParameters.{});
EmcStatusUserCommand :: struct {
    index: s32;
    command: *string;

    _desc_table :: struct {
        index := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        command := FieldDesc.{tag=2, type=type_of(string), optional=true, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: EmcStatusUserCommand) {
        #insert #run encode_code_writer(EmcStatusUserCommand.{});
    }

    decode :: (b: []u8) -> EmcStatusUserCommand {
        #insert #run decode_code_writer(EmcStatusUserCommand.{});
    }

};
#insert #run setters_code_writer(EmcStatusUserCommand.{});
EmcStatusUI :: struct {
    spindle_brake_visible: *bool;
    spindle_cw_visible: *bool;
    spindle_ccw_visible: *bool;
    spindle_stop_visible: *bool;
    spindle_plus_visible: *bool;
    spindle_minus_visible: *bool;
    spindle_override_visible: *bool;
    coolant_flood_visible: *bool;
    coolant_mist_visible: *bool;

    _desc_table :: struct {
        spindle_brake_visible := FieldDesc.{tag=1, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        spindle_cw_visible := FieldDesc.{tag=2, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        spindle_ccw_visible := FieldDesc.{tag=3, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        spindle_stop_visible := FieldDesc.{tag=4, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        spindle_plus_visible := FieldDesc.{tag=5, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        spindle_minus_visible := FieldDesc.{tag=6, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        spindle_override_visible := FieldDesc.{tag=7, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        coolant_flood_visible := FieldDesc.{tag=8, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        coolant_mist_visible := FieldDesc.{tag=9, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: EmcStatusUI) {
        #insert #run encode_code_writer(EmcStatusUI.{});
    }

    decode :: (b: []u8) -> EmcStatusUI {
        #insert #run decode_code_writer(EmcStatusUI.{});
    }

};
#insert #run setters_code_writer(EmcStatusUI.{});
