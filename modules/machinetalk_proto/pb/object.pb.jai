// Code generated by protoc-gen-jai

#import "proto";
#import "Basic";
#import "Deep_Copy";

Instance :: struct {
    name: *string;
    id: *s32;

    _desc_table :: struct {
        name := FieldDesc.{tag=1, type=type_of(string), optional=true, repeated=false, wt=.Size};
        id := FieldDesc.{tag=2, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
    };

    encode :: (b: *[..]u8, self: Instance) {
        #insert #run encode_code_writer(Instance.{});
    }

    decode :: (b: []u8) -> Instance {
        #insert #run decode_code_writer(Instance.{});
    }

};
#insert #run setters_code_writer(Instance.{});
ServiceAnnouncement :: struct {
    stype: ServiceType;
    version: u32;
    instance: u32;
    api: ServiceAPI;
    uri: string;
    description: *string;

    _desc_table :: struct {
        stype := FieldDesc.{tag=1, type=type_of(ServiceType), optional=false, repeated=false, wt=.Varint};
        version := FieldDesc.{tag=2, type=type_of(u32), optional=false, repeated=false, wt=.Fixed32};
        instance := FieldDesc.{tag=3, type=type_of(u32), optional=false, repeated=false, wt=.Fixed32};
        api := FieldDesc.{tag=8, type=type_of(ServiceAPI), optional=false, repeated=false, wt=.Varint};
        uri := FieldDesc.{tag=6, type=type_of(string), optional=false, repeated=false, wt=.Size};
        description := FieldDesc.{tag=7, type=type_of(string), optional=true, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: ServiceAnnouncement) {
        #insert #run encode_code_writer(ServiceAnnouncement.{});
    }

    decode :: (b: []u8) -> ServiceAnnouncement {
        #insert #run decode_code_writer(ServiceAnnouncement.{});
    }

};
#insert #run setters_code_writer(ServiceAnnouncement.{});
Originator :: struct {
    origin: *OriginType;
    detail: *OriginDetail;
    name: *string;
    id: *s32;
    instance: *Instance;

    _desc_table :: struct {
        origin := FieldDesc.{tag=1, type=type_of(OriginType), optional=true, repeated=false, wt=.Varint};
        detail := FieldDesc.{tag=2, type=type_of(OriginDetail), optional=true, repeated=false, wt=.Varint};
        name := FieldDesc.{tag=3, type=type_of(string), optional=true, repeated=false, wt=.Size};
        id := FieldDesc.{tag=4, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        instance := FieldDesc.{tag=5, type=type_of(Instance), optional=true, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Originator) {
        #insert #run encode_code_writer(Originator.{});
    }

    decode :: (b: []u8) -> Originator {
        #insert #run decode_code_writer(Originator.{});
    }

};
#insert #run setters_code_writer(Originator.{});
AnError :: struct {
    error_code: s32;
    severity: *Severity;
    error_text: *string;
    origin: *Originator;

    _desc_table :: struct {
        error_code := FieldDesc.{tag=1, type=type_of(s32), optional=false, repeated=false, wt=.Fixed32};
        severity := FieldDesc.{tag=2, type=type_of(Severity), optional=true, repeated=false, wt=.Varint};
        error_text := FieldDesc.{tag=3, type=type_of(string), optional=true, repeated=false, wt=.Size};
        origin := FieldDesc.{tag=4, type=type_of(Originator), optional=true, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: AnError) {
        #insert #run encode_code_writer(AnError.{});
    }

    decode :: (b: []u8) -> AnError {
        #insert #run decode_code_writer(AnError.{});
    }

};
#insert #run setters_code_writer(AnError.{});
Pin :: struct {
    type: *ValueType;
    name: *string;
    handle: *u32;
    dir: *HalPinDirection;
    halbit: *bool;
    halfloat: *float64;
    hals32: *s32;
    halu32: *u32;
    owner: *s32;
    linked: *bool;
    oldname: *string;
    epsilon: *float64;
    flags: *u32;

    _desc_table :: struct {
        type := FieldDesc.{tag=1, type=type_of(ValueType), optional=true, repeated=false, wt=.Varint};
        name := FieldDesc.{tag=2, type=type_of(string), optional=true, repeated=false, wt=.Size};
        handle := FieldDesc.{tag=3, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        dir := FieldDesc.{tag=4, type=type_of(HalPinDirection), optional=true, repeated=false, wt=.Varint};
        halbit := FieldDesc.{tag=5, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        halfloat := FieldDesc.{tag=6, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        hals32 := FieldDesc.{tag=7, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        halu32 := FieldDesc.{tag=8, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        owner := FieldDesc.{tag=9, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        linked := FieldDesc.{tag=10, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        oldname := FieldDesc.{tag=11, type=type_of(string), optional=true, repeated=false, wt=.Size};
        epsilon := FieldDesc.{tag=12, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        flags := FieldDesc.{tag=13, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
    };

    encode :: (b: *[..]u8, self: Pin) {
        #insert #run encode_code_writer(Pin.{});
    }

    decode :: (b: []u8) -> Pin {
        #insert #run decode_code_writer(Pin.{});
    }

};
#insert #run setters_code_writer(Pin.{});
Signal :: struct {
    type: *ValueType;
    name: *string;
    handle: *u32;
    halbit: *bool;
    halfloat: *float64;
    hals32: *s32;
    halu32: *u32;
    strval: *string;
    blob: *string;
    readers: *u32;
    writers: *u32;
    bidirs: *u32;

    _desc_table :: struct {
        type := FieldDesc.{tag=1, type=type_of(ValueType), optional=true, repeated=false, wt=.Varint};
        name := FieldDesc.{tag=2, type=type_of(string), optional=true, repeated=false, wt=.Size};
        handle := FieldDesc.{tag=3, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        halbit := FieldDesc.{tag=5, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        halfloat := FieldDesc.{tag=6, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        hals32 := FieldDesc.{tag=7, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        halu32 := FieldDesc.{tag=8, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        strval := FieldDesc.{tag=9, type=type_of(string), optional=true, repeated=false, wt=.Size};
        blob := FieldDesc.{tag=10, type=type_of(string), optional=true, repeated=false, wt=.Size};
        readers := FieldDesc.{tag=11, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        writers := FieldDesc.{tag=12, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        bidirs := FieldDesc.{tag=13, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
    };

    encode :: (b: *[..]u8, self: Signal) {
        #insert #run encode_code_writer(Signal.{});
    }

    decode :: (b: []u8) -> Signal {
        #insert #run decode_code_writer(Signal.{});
    }

};
#insert #run setters_code_writer(Signal.{});
Param :: struct {
    type: *ValueType;
    name: *string;
    handle: *u32;
    halbit: *bool;
    halfloat: *float64;
    hals32: *s32;
    halu32: *u32;
    strval: *string;
    blob: *string;
    dir: *HalParamDirection;
    oldname: *string;
    owner: *s32;
    runtime: *s32;
    maytime: *s32;

    _desc_table :: struct {
        type := FieldDesc.{tag=1, type=type_of(ValueType), optional=true, repeated=false, wt=.Varint};
        name := FieldDesc.{tag=2, type=type_of(string), optional=true, repeated=false, wt=.Size};
        handle := FieldDesc.{tag=3, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        halbit := FieldDesc.{tag=5, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        halfloat := FieldDesc.{tag=6, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        hals32 := FieldDesc.{tag=7, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        halu32 := FieldDesc.{tag=8, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        strval := FieldDesc.{tag=9, type=type_of(string), optional=true, repeated=false, wt=.Size};
        blob := FieldDesc.{tag=10, type=type_of(string), optional=true, repeated=false, wt=.Size};
        dir := FieldDesc.{tag=11, type=type_of(HalParamDirection), optional=true, repeated=false, wt=.Varint};
        oldname := FieldDesc.{tag=12, type=type_of(string), optional=true, repeated=false, wt=.Size};
        owner := FieldDesc.{tag=13, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        runtime := FieldDesc.{tag=14, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        maytime := FieldDesc.{tag=15, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
    };

    encode :: (b: *[..]u8, self: Param) {
        #insert #run encode_code_writer(Param.{});
    }

    decode :: (b: []u8) -> Param {
        #insert #run decode_code_writer(Param.{});
    }

};
#insert #run setters_code_writer(Param.{});
Function :: struct {
    name: *string;
    handle: *u32;
    owner_id: *u32;
    users: *u32;
    runtime: *u32;
    maxtime: *u32;
    reentrant: *bool;
    type: *HalFunctType;
    maxtime_increased: *bool;

    _desc_table :: struct {
        name := FieldDesc.{tag=1, type=type_of(string), optional=true, repeated=false, wt=.Size};
        handle := FieldDesc.{tag=2, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        owner_id := FieldDesc.{tag=3, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        users := FieldDesc.{tag=4, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        runtime := FieldDesc.{tag=5, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        maxtime := FieldDesc.{tag=6, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        reentrant := FieldDesc.{tag=7, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        type := FieldDesc.{tag=8, type=type_of(HalFunctType), optional=true, repeated=false, wt=.Varint};
        maxtime_increased := FieldDesc.{tag=9, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Function) {
        #insert #run encode_code_writer(Function.{});
    }

    decode :: (b: []u8) -> Function {
        #insert #run decode_code_writer(Function.{});
    }

};
#insert #run setters_code_writer(Function.{});
Thread :: struct {
    name: *string;
    handle: *u32;
    uses_fp: *bool;
    period: *u32;
    priority: *s32;
    task_id: *u32;
    cpu_id: *u32;
    function: [..]string;

    _desc_table :: struct {
        name := FieldDesc.{tag=1, type=type_of(string), optional=true, repeated=false, wt=.Size};
        handle := FieldDesc.{tag=2, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        uses_fp := FieldDesc.{tag=3, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        period := FieldDesc.{tag=4, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        priority := FieldDesc.{tag=5, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        task_id := FieldDesc.{tag=6, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        cpu_id := FieldDesc.{tag=7, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        function := FieldDesc.{tag=8, type=type_of(string), optional=false, repeated=true, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Thread) {
        #insert #run encode_code_writer(Thread.{});
    }

    decode :: (b: []u8) -> Thread {
        #insert #run decode_code_writer(Thread.{});
    }

};
#insert #run setters_code_writer(Thread.{});
Component :: struct {
    name: *string;
    ninst: *u32;
    comp_id: *s32;
    type: *u32;
    state: *u32;
    last_update: *u32;
    last_bound: *u32;
    last_unbound: *u32;
    pid: *u32;
    args: *string;
    timer: *s32;
    userarg1: *s32;
    userarg2: *s32;
    pin: [..]Pin;
    param: [..]Param;
    funct: [..]Function;
    no_create: *bool;

    _desc_table :: struct {
        name := FieldDesc.{tag=1, type=type_of(string), optional=true, repeated=false, wt=.Size};
        ninst := FieldDesc.{tag=2, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        comp_id := FieldDesc.{tag=4, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        type := FieldDesc.{tag=5, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        state := FieldDesc.{tag=6, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        last_update := FieldDesc.{tag=7, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        last_bound := FieldDesc.{tag=8, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        last_unbound := FieldDesc.{tag=9, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        pid := FieldDesc.{tag=10, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        args := FieldDesc.{tag=11, type=type_of(string), optional=true, repeated=false, wt=.Size};
        timer := FieldDesc.{tag=12, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        userarg1 := FieldDesc.{tag=14, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        userarg2 := FieldDesc.{tag=15, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        pin := FieldDesc.{tag=16, type=type_of(Pin), optional=false, repeated=true, wt=.Size};
        param := FieldDesc.{tag=17, type=type_of(Param), optional=false, repeated=true, wt=.Size};
        funct := FieldDesc.{tag=19, type=type_of(Function), optional=false, repeated=true, wt=.Size};
        no_create := FieldDesc.{tag=18, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Component) {
        #insert #run encode_code_writer(Component.{});
    }

    decode :: (b: []u8) -> Component {
        #insert #run decode_code_writer(Component.{});
    }

};
#insert #run setters_code_writer(Component.{});
Ring :: struct {
    name: *string;
    handle: *u32;
    owner: *s32;
    stream: *bool;
    wmutex: *bool;
    rmutex: *bool;
    rtapi_shm: *bool;
    reader: *s32;
    writer: *s32;
    total_size: *s32;
    scratchpad: *s32;
    ring_shmkey: *s32;
    encodings: *u32;

    _desc_table :: struct {
        name := FieldDesc.{tag=1, type=type_of(string), optional=true, repeated=false, wt=.Size};
        handle := FieldDesc.{tag=2, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        owner := FieldDesc.{tag=3, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        stream := FieldDesc.{tag=4, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        wmutex := FieldDesc.{tag=5, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        rmutex := FieldDesc.{tag=6, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        rtapi_shm := FieldDesc.{tag=7, type=type_of(bool), optional=true, repeated=false, wt=.Varint};
        reader := FieldDesc.{tag=8, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        writer := FieldDesc.{tag=9, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        total_size := FieldDesc.{tag=10, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        scratchpad := FieldDesc.{tag=11, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        ring_shmkey := FieldDesc.{tag=12, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        encodings := FieldDesc.{tag=13, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
    };

    encode :: (b: *[..]u8, self: Ring) {
        #insert #run encode_code_writer(Ring.{});
    }

    decode :: (b: []u8) -> Ring {
        #insert #run decode_code_writer(Ring.{});
    }

};
#insert #run setters_code_writer(Ring.{});
Member :: struct {
    mtype: *ObjectType;
    userarg1: *s32;
    epsilon: *float64;
    signal: *Signal;
    groupname: *string;
    handle: *u32;
    pin: *Pin;
    param: *Param;

    _desc_table :: struct {
        mtype := FieldDesc.{tag=1, type=type_of(ObjectType), optional=true, repeated=false, wt=.Varint};
        userarg1 := FieldDesc.{tag=2, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        epsilon := FieldDesc.{tag=3, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        signal := FieldDesc.{tag=4, type=type_of(Signal), optional=true, repeated=false, wt=.Size};
        groupname := FieldDesc.{tag=5, type=type_of(string), optional=true, repeated=false, wt=.Size};
        handle := FieldDesc.{tag=6, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        pin := FieldDesc.{tag=7, type=type_of(Pin), optional=true, repeated=false, wt=.Size};
        param := FieldDesc.{tag=8, type=type_of(Param), optional=true, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Member) {
        #insert #run encode_code_writer(Member.{});
    }

    decode :: (b: []u8) -> Member {
        #insert #run decode_code_writer(Member.{});
    }

};
#insert #run setters_code_writer(Member.{});
Group :: struct {
    name: *string;
    handle: *u32;
    userarg1: *s32;
    userarg2: *s32;
    refcount: *s32;
    member: [..]Member;

    _desc_table :: struct {
        name := FieldDesc.{tag=1, type=type_of(string), optional=true, repeated=false, wt=.Size};
        handle := FieldDesc.{tag=2, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        userarg1 := FieldDesc.{tag=4, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        userarg2 := FieldDesc.{tag=5, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        refcount := FieldDesc.{tag=6, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        member := FieldDesc.{tag=7, type=type_of(Member), optional=false, repeated=true, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Group) {
        #insert #run encode_code_writer(Group.{});
    }

    decode :: (b: []u8) -> Group {
        #insert #run decode_code_writer(Group.{});
    }

};
#insert #run setters_code_writer(Group.{});
ProtocolParameters :: struct {
    keepalive_timer: *s32;
    group_timer: *s32;
    rcomp_timer: *s32;

    _desc_table :: struct {
        keepalive_timer := FieldDesc.{tag=1, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        group_timer := FieldDesc.{tag=2, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        rcomp_timer := FieldDesc.{tag=3, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
    };

    encode :: (b: *[..]u8, self: ProtocolParameters) {
        #insert #run encode_code_writer(ProtocolParameters.{});
    }

    decode :: (b: []u8) -> ProtocolParameters {
        #insert #run decode_code_writer(ProtocolParameters.{});
    }

};
#insert #run setters_code_writer(ProtocolParameters.{});
Vtable :: struct {
    name: *string;
    handle: *u32;
    owner_id: *s32;
    __name__context: *u32;
    refcount: *s32;
    version: *s32;
    vtable: *u64;

    _desc_table :: struct {
        name := FieldDesc.{tag=1, type=type_of(string), optional=true, repeated=false, wt=.Size};
        handle := FieldDesc.{tag=2, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        owner_id := FieldDesc.{tag=3, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        __name__context := FieldDesc.{tag=5, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        refcount := FieldDesc.{tag=6, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        version := FieldDesc.{tag=7, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        vtable := FieldDesc.{tag=8, type=type_of(u64), optional=true, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: Vtable) {
        #insert #run encode_code_writer(Vtable.{});
    }

    decode :: (b: []u8) -> Vtable {
        #insert #run decode_code_writer(Vtable.{});
    }

};
#insert #run setters_code_writer(Vtable.{});
Inst :: struct {
    name: *string;
    comp_id: *s32;
    inst_id: *u32;
    inst_size: *u32;
    vtable: *u64;
    pin: [..]Pin;
    param: [..]Param;
    funct: [..]Function;

    _desc_table :: struct {
        name := FieldDesc.{tag=1, type=type_of(string), optional=true, repeated=false, wt=.Size};
        comp_id := FieldDesc.{tag=2, type=type_of(s32), optional=true, repeated=false, wt=.Fixed32};
        inst_id := FieldDesc.{tag=3, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        inst_size := FieldDesc.{tag=4, type=type_of(u32), optional=true, repeated=false, wt=.Fixed32};
        vtable := FieldDesc.{tag=5, type=type_of(u64), optional=true, repeated=false, wt=.Fixed64};
        pin := FieldDesc.{tag=16, type=type_of(Pin), optional=false, repeated=true, wt=.Size};
        param := FieldDesc.{tag=17, type=type_of(Param), optional=false, repeated=true, wt=.Size};
        funct := FieldDesc.{tag=19, type=type_of(Function), optional=false, repeated=true, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Inst) {
        #insert #run encode_code_writer(Inst.{});
    }

    decode :: (b: []u8) -> Inst {
        #insert #run decode_code_writer(Inst.{});
    }

};
#insert #run setters_code_writer(Inst.{});
