// Code generated by protoc-gen-jai

#import "proto";
#import "Basic";
#import "Deep_Copy";

Time :: struct {
    secs: *u32;
    nsecs: *u32;

    _desc_table :: struct {
        secs := FieldDesc.{tag=1, type=type_of(u32), optional=true, repeated=false, wt=.Varint};
        nsecs := FieldDesc.{tag=2, type=type_of(u32), optional=true, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Time) {
        #insert #run encode_code_writer(Time.{});
    }

    decode :: (b: []u8) -> Time {
        #insert #run decode_code_writer(Time.{});
    }

};
#insert #run setters_code_writer(Time.{});
Header :: struct {
    seq: *u32;
    stamp: *Time;
    frame_id: *string;

    _desc_table :: struct {
        seq := FieldDesc.{tag=1, type=type_of(u32), optional=true, repeated=false, wt=.Varint};
        stamp := FieldDesc.{tag=2, type=type_of(Time), optional=true, repeated=false, wt=.Size};
        frame_id := FieldDesc.{tag=3, type=type_of(string), optional=true, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Header) {
        #insert #run encode_code_writer(Header.{});
    }

    decode :: (b: []u8) -> Header {
        #insert #run decode_code_writer(Header.{});
    }

};
#insert #run setters_code_writer(Header.{});
JointTrajectoryPoint :: struct {
    positions: [..]float64;
    velocities: [..]float64;
    accelerations: [..]float64;
    effort: [..]float64;
    time_from_start: *float64;
    duration: *float64;
    serial: *u32;

    _desc_table :: struct {
        positions := FieldDesc.{tag=1, type=type_of(float64), optional=false, repeated=true, wt=.Fixed64};
        velocities := FieldDesc.{tag=2, type=type_of(float64), optional=false, repeated=true, wt=.Fixed64};
        accelerations := FieldDesc.{tag=3, type=type_of(float64), optional=false, repeated=true, wt=.Fixed64};
        effort := FieldDesc.{tag=4, type=type_of(float64), optional=false, repeated=true, wt=.Fixed64};
        time_from_start := FieldDesc.{tag=5, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        duration := FieldDesc.{tag=7, type=type_of(float64), optional=true, repeated=false, wt=.Fixed64};
        serial := FieldDesc.{tag=8, type=type_of(u32), optional=true, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: JointTrajectoryPoint) {
        #insert #run encode_code_writer(JointTrajectoryPoint.{});
    }

    decode :: (b: []u8) -> JointTrajectoryPoint {
        #insert #run decode_code_writer(JointTrajectoryPoint.{});
    }

};
#insert #run setters_code_writer(JointTrajectoryPoint.{});
JointTrajectory :: struct {
    header: *Header;
    joint_names: [..]string;
    points: [..]JointTrajectoryPoint;

    _desc_table :: struct {
        header := FieldDesc.{tag=1, type=type_of(Header), optional=true, repeated=false, wt=.Size};
        joint_names := FieldDesc.{tag=2, type=type_of(string), optional=false, repeated=true, wt=.Size};
        points := FieldDesc.{tag=3, type=type_of(JointTrajectoryPoint), optional=false, repeated=true, wt=.Size};
    };

    encode :: (b: *[..]u8, self: JointTrajectory) {
        #insert #run encode_code_writer(JointTrajectory.{});
    }

    decode :: (b: []u8) -> JointTrajectory {
        #insert #run decode_code_writer(JointTrajectory.{});
    }

};
#insert #run setters_code_writer(JointTrajectory.{});
