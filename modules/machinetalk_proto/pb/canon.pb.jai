// Code generated by protoc-gen-jai

#import "proto";
#import "Basic";
#import "Deep_Copy";

Emc_Traj_Set_G5x :: struct {
    origin: EmcPose;
    g5x_index: OriginIndex;

    _desc_table :: struct {
        origin := FieldDesc.{tag=10, type=type_of(EmcPose), optional=false, repeated=false, wt=.Size};
        g5x_index := FieldDesc.{tag=20, type=type_of(OriginIndex), optional=false, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Set_G5x) {
        #insert #run encode_code_writer(Emc_Traj_Set_G5x.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Set_G5x {
        #insert #run decode_code_writer(Emc_Traj_Set_G5x.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Set_G5x.{});
Emc_Traj_Set_G92 :: struct {
    origin: EmcPose;

    _desc_table :: struct {
        origin := FieldDesc.{tag=10, type=type_of(EmcPose), optional=false, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Set_G92) {
        #insert #run encode_code_writer(Emc_Traj_Set_G92.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Set_G92 {
        #insert #run decode_code_writer(Emc_Traj_Set_G92.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Set_G92.{});
Emc_Traj_Set_Rotation :: struct {
    rotation: float64;

    _desc_table :: struct {
        rotation := FieldDesc.{tag=10, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Set_Rotation) {
        #insert #run encode_code_writer(Emc_Traj_Set_Rotation.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Set_Rotation {
        #insert #run decode_code_writer(Emc_Traj_Set_Rotation.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Set_Rotation.{});
Emc_Traj_Linear_Move :: struct {
    type: MotionType;
    end: EmcPose;
    vel: float64;
    ini_maxvel: float64;
    acc: float64;
    feed_mode: bool;
    indexrotary: s32;

    _desc_table :: struct {
        type := FieldDesc.{tag=10, type=type_of(MotionType), optional=false, repeated=false, wt=.Varint};
        end := FieldDesc.{tag=20, type=type_of(EmcPose), optional=false, repeated=false, wt=.Size};
        vel := FieldDesc.{tag=30, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        ini_maxvel := FieldDesc.{tag=40, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        acc := FieldDesc.{tag=50, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        feed_mode := FieldDesc.{tag=60, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
        indexrotary := FieldDesc.{tag=70, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Linear_Move) {
        #insert #run encode_code_writer(Emc_Traj_Linear_Move.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Linear_Move {
        #insert #run decode_code_writer(Emc_Traj_Linear_Move.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Linear_Move.{});
Emc_Traj_Probe :: struct {
    type: MotionType;
    pos: EmcPose;
    vel: float64;
    ini_maxvel: float64;
    acc: float64;
    probe_type: u32;

    _desc_table :: struct {
        type := FieldDesc.{tag=10, type=type_of(MotionType), optional=false, repeated=false, wt=.Varint};
        pos := FieldDesc.{tag=20, type=type_of(EmcPose), optional=false, repeated=false, wt=.Size};
        vel := FieldDesc.{tag=30, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        ini_maxvel := FieldDesc.{tag=40, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        acc := FieldDesc.{tag=50, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        probe_type := FieldDesc.{tag=60, type=type_of(u32), optional=false, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Probe) {
        #insert #run encode_code_writer(Emc_Traj_Probe.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Probe {
        #insert #run decode_code_writer(Emc_Traj_Probe.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Probe.{});
Emc_Traj_Circular_Move :: struct {
    type: MotionType;
    end: EmcPose;
    center: PmCartesian;
    normal: PmCartesian;
    vel: float64;
    ini_maxvel: float64;
    acc: float64;
    feed_mode: bool;
    turn: s32;

    _desc_table :: struct {
        type := FieldDesc.{tag=10, type=type_of(MotionType), optional=false, repeated=false, wt=.Varint};
        end := FieldDesc.{tag=20, type=type_of(EmcPose), optional=false, repeated=false, wt=.Size};
        center := FieldDesc.{tag=25, type=type_of(PmCartesian), optional=false, repeated=false, wt=.Size};
        normal := FieldDesc.{tag=27, type=type_of(PmCartesian), optional=false, repeated=false, wt=.Size};
        vel := FieldDesc.{tag=30, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        ini_maxvel := FieldDesc.{tag=40, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        acc := FieldDesc.{tag=50, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        feed_mode := FieldDesc.{tag=60, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
        turn := FieldDesc.{tag=70, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Circular_Move) {
        #insert #run encode_code_writer(Emc_Traj_Circular_Move.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Circular_Move {
        #insert #run decode_code_writer(Emc_Traj_Circular_Move.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Circular_Move.{});
Emc_Traj_Rigid_Tap :: struct {
    pos: EmcPose;
    vel: float64;
    ini_maxvel: float64;
    acc: float64;

    _desc_table :: struct {
        pos := FieldDesc.{tag=20, type=type_of(EmcPose), optional=false, repeated=false, wt=.Size};
        vel := FieldDesc.{tag=30, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        ini_maxvel := FieldDesc.{tag=40, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        acc := FieldDesc.{tag=50, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Rigid_Tap) {
        #insert #run encode_code_writer(Emc_Traj_Rigid_Tap.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Rigid_Tap {
        #insert #run decode_code_writer(Emc_Traj_Rigid_Tap.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Rigid_Tap.{});
Emc_Traj_Set_Term_Cond :: struct {
    cond: TermConditionType;
    tolerance: float64;

    _desc_table :: struct {
        cond := FieldDesc.{tag=10, type=type_of(TermConditionType), optional=false, repeated=false, wt=.Varint};
        tolerance := FieldDesc.{tag=20, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Set_Term_Cond) {
        #insert #run encode_code_writer(Emc_Traj_Set_Term_Cond.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Set_Term_Cond {
        #insert #run decode_code_writer(Emc_Traj_Set_Term_Cond.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Set_Term_Cond.{});
Emc_Traj_Set_Spindlesync :: struct {
    feed_per_revolution: float64;
    velocity_mode: bool;

    _desc_table :: struct {
        feed_per_revolution := FieldDesc.{tag=10, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        velocity_mode := FieldDesc.{tag=20, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Set_Spindlesync) {
        #insert #run encode_code_writer(Emc_Traj_Set_Spindlesync.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Set_Spindlesync {
        #insert #run decode_code_writer(Emc_Traj_Set_Spindlesync.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Set_Spindlesync.{});
Emc_Traj_Delay :: struct {
    delay: float64;

    _desc_table :: struct {
        delay := FieldDesc.{tag=10, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Delay) {
        #insert #run encode_code_writer(Emc_Traj_Delay.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Delay {
        #insert #run decode_code_writer(Emc_Traj_Delay.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Delay.{});
Emc_Spindle_On :: struct {
    speed: float64;
    factor: float64;
    xoffset: float64;

    _desc_table :: struct {
        speed := FieldDesc.{tag=10, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        factor := FieldDesc.{tag=20, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        xoffset := FieldDesc.{tag=30, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: Emc_Spindle_On) {
        #insert #run encode_code_writer(Emc_Spindle_On.{});
    }

    decode :: (b: []u8) -> Emc_Spindle_On {
        #insert #run decode_code_writer(Emc_Spindle_On.{});
    }

};
#insert #run setters_code_writer(Emc_Spindle_On.{});
Emc_Spindle_Speed :: struct {
    speed: float64;
    factor: float64;
    xoffset: float64;

    _desc_table :: struct {
        speed := FieldDesc.{tag=10, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        factor := FieldDesc.{tag=20, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        xoffset := FieldDesc.{tag=30, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: Emc_Spindle_Speed) {
        #insert #run encode_code_writer(Emc_Spindle_Speed.{});
    }

    decode :: (b: []u8) -> Emc_Spindle_Speed {
        #insert #run decode_code_writer(Emc_Spindle_Speed.{});
    }

};
#insert #run setters_code_writer(Emc_Spindle_Speed.{});
Emc_Spindle_Orient :: struct {
    orientation: float64;
    mode: CanonDirection;

    _desc_table :: struct {
        orientation := FieldDesc.{tag=10, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        mode := FieldDesc.{tag=20, type=type_of(CanonDirection), optional=false, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Emc_Spindle_Orient) {
        #insert #run encode_code_writer(Emc_Spindle_Orient.{});
    }

    decode :: (b: []u8) -> Emc_Spindle_Orient {
        #insert #run decode_code_writer(Emc_Spindle_Orient.{});
    }

};
#insert #run setters_code_writer(Emc_Spindle_Orient.{});
Emc_Spindle_Wait_Orient_Complete :: struct {
    timeout: float64;

    _desc_table :: struct {
        timeout := FieldDesc.{tag=10, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: Emc_Spindle_Wait_Orient_Complete) {
        #insert #run encode_code_writer(Emc_Spindle_Wait_Orient_Complete.{});
    }

    decode :: (b: []u8) -> Emc_Spindle_Wait_Orient_Complete {
        #insert #run decode_code_writer(Emc_Spindle_Wait_Orient_Complete.{});
    }

};
#insert #run setters_code_writer(Emc_Spindle_Wait_Orient_Complete.{});
Emc_Tool_Set_Offset :: struct {
    pocket: s32;
    toolno: s32;
    offset: EmcPose;
    diameter: float64;
    frontangle: float64;
    backangle: float64;
    orientation: s32;

    _desc_table :: struct {
        pocket := FieldDesc.{tag=10, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        toolno := FieldDesc.{tag=15, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        offset := FieldDesc.{tag=20, type=type_of(EmcPose), optional=false, repeated=false, wt=.Size};
        diameter := FieldDesc.{tag=30, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        frontangle := FieldDesc.{tag=40, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        backangle := FieldDesc.{tag=50, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        orientation := FieldDesc.{tag=60, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: Emc_Tool_Set_Offset) {
        #insert #run encode_code_writer(Emc_Tool_Set_Offset.{});
    }

    decode :: (b: []u8) -> Emc_Tool_Set_Offset {
        #insert #run decode_code_writer(Emc_Tool_Set_Offset.{});
    }

};
#insert #run setters_code_writer(Emc_Tool_Set_Offset.{});
Emc_Traj_Set_Offset :: struct {
    offset: EmcPose;

    _desc_table :: struct {
        offset := FieldDesc.{tag=10, type=type_of(EmcPose), optional=false, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Set_Offset) {
        #insert #run encode_code_writer(Emc_Traj_Set_Offset.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Set_Offset {
        #insert #run decode_code_writer(Emc_Traj_Set_Offset.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Set_Offset.{});
Emc_Tool_Prepare :: struct {
    pocket: s32;
    tool: s32;

    _desc_table :: struct {
        pocket := FieldDesc.{tag=10, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        tool := FieldDesc.{tag=20, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: Emc_Tool_Prepare) {
        #insert #run encode_code_writer(Emc_Tool_Prepare.{});
    }

    decode :: (b: []u8) -> Emc_Tool_Prepare {
        #insert #run decode_code_writer(Emc_Tool_Prepare.{});
    }

};
#insert #run setters_code_writer(Emc_Tool_Prepare.{});
Emc_Tool_Set_Number :: struct {
    tool: s32;

    _desc_table :: struct {
        tool := FieldDesc.{tag=10, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
    };

    encode :: (b: *[..]u8, self: Emc_Tool_Set_Number) {
        #insert #run encode_code_writer(Emc_Tool_Set_Number.{});
    }

    decode :: (b: []u8) -> Emc_Tool_Set_Number {
        #insert #run decode_code_writer(Emc_Tool_Set_Number.{});
    }

};
#insert #run setters_code_writer(Emc_Tool_Set_Number.{});
Emc_Traj_Set_Fo_Enable :: struct {
    mode: bool;

    _desc_table :: struct {
        mode := FieldDesc.{tag=10, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Set_Fo_Enable) {
        #insert #run encode_code_writer(Emc_Traj_Set_Fo_Enable.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Set_Fo_Enable {
        #insert #run decode_code_writer(Emc_Traj_Set_Fo_Enable.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Set_Fo_Enable.{});
Emc_Traj_Set_So_Enable :: struct {
    mode: bool;

    _desc_table :: struct {
        mode := FieldDesc.{tag=10, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Set_So_Enable) {
        #insert #run encode_code_writer(Emc_Traj_Set_So_Enable.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Set_So_Enable {
        #insert #run decode_code_writer(Emc_Traj_Set_So_Enable.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Set_So_Enable.{});
Emc_Traj_Set_Fh_Enable :: struct {
    mode: bool;

    _desc_table :: struct {
        mode := FieldDesc.{tag=10, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Emc_Traj_Set_Fh_Enable) {
        #insert #run encode_code_writer(Emc_Traj_Set_Fh_Enable.{});
    }

    decode :: (b: []u8) -> Emc_Traj_Set_Fh_Enable {
        #insert #run decode_code_writer(Emc_Traj_Set_Fh_Enable.{});
    }

};
#insert #run setters_code_writer(Emc_Traj_Set_Fh_Enable.{});
Emc_Motion_Adaptive :: struct {
    status: bool;

    _desc_table :: struct {
        status := FieldDesc.{tag=10, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Emc_Motion_Adaptive) {
        #insert #run encode_code_writer(Emc_Motion_Adaptive.{});
    }

    decode :: (b: []u8) -> Emc_Motion_Adaptive {
        #insert #run decode_code_writer(Emc_Motion_Adaptive.{});
    }

};
#insert #run setters_code_writer(Emc_Motion_Adaptive.{});
Emc_Operator_Display :: struct {
    id: s32;
    display: string;

    _desc_table :: struct {
        id := FieldDesc.{tag=10, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        display := FieldDesc.{tag=20, type=type_of(string), optional=false, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Emc_Operator_Display) {
        #insert #run encode_code_writer(Emc_Operator_Display.{});
    }

    decode :: (b: []u8) -> Emc_Operator_Display {
        #insert #run decode_code_writer(Emc_Operator_Display.{});
    }

};
#insert #run setters_code_writer(Emc_Operator_Display.{});
Emc_Operator_Text :: struct {
    id: s32;
    text: string;

    _desc_table :: struct {
        id := FieldDesc.{tag=10, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        text := FieldDesc.{tag=20, type=type_of(string), optional=false, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Emc_Operator_Text) {
        #insert #run encode_code_writer(Emc_Operator_Text.{});
    }

    decode :: (b: []u8) -> Emc_Operator_Text {
        #insert #run decode_code_writer(Emc_Operator_Text.{});
    }

};
#insert #run setters_code_writer(Emc_Operator_Text.{});
Emc_Operator_Error :: struct {
    id: s32;
    error: string;

    _desc_table :: struct {
        id := FieldDesc.{tag=10, type=type_of(s32), optional=false, repeated=false, wt=.ZigZag};
        error := FieldDesc.{tag=20, type=type_of(string), optional=false, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Emc_Operator_Error) {
        #insert #run encode_code_writer(Emc_Operator_Error.{});
    }

    decode :: (b: []u8) -> Emc_Operator_Error {
        #insert #run decode_code_writer(Emc_Operator_Error.{});
    }

};
#insert #run setters_code_writer(Emc_Operator_Error.{});
Emc_Motion_Set_Dout :: struct {
    index: u32;
    start: bool;
    end: bool;
    now: bool;

    _desc_table :: struct {
        index := FieldDesc.{tag=10, type=type_of(u32), optional=false, repeated=false, wt=.Varint};
        start := FieldDesc.{tag=20, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
        end := FieldDesc.{tag=30, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
        now := FieldDesc.{tag=40, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Emc_Motion_Set_Dout) {
        #insert #run encode_code_writer(Emc_Motion_Set_Dout.{});
    }

    decode :: (b: []u8) -> Emc_Motion_Set_Dout {
        #insert #run decode_code_writer(Emc_Motion_Set_Dout.{});
    }

};
#insert #run setters_code_writer(Emc_Motion_Set_Dout.{});
Emc_Motion_Set_Aout :: struct {
    index: u32;
    start: float64;
    end: float64;
    now: bool;

    _desc_table :: struct {
        index := FieldDesc.{tag=10, type=type_of(u32), optional=false, repeated=false, wt=.Varint};
        start := FieldDesc.{tag=20, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        end := FieldDesc.{tag=30, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
        now := FieldDesc.{tag=40, type=type_of(bool), optional=false, repeated=false, wt=.Varint};
    };

    encode :: (b: *[..]u8, self: Emc_Motion_Set_Aout) {
        #insert #run encode_code_writer(Emc_Motion_Set_Aout.{});
    }

    decode :: (b: []u8) -> Emc_Motion_Set_Aout {
        #insert #run decode_code_writer(Emc_Motion_Set_Aout.{});
    }

};
#insert #run setters_code_writer(Emc_Motion_Set_Aout.{});
Emc_Aux_Input_Wait :: struct {
    index: u32;
    input_type: InputType;
    wait_type: WaitType;
    timeout: float64;

    _desc_table :: struct {
        index := FieldDesc.{tag=10, type=type_of(u32), optional=false, repeated=false, wt=.Varint};
        input_type := FieldDesc.{tag=20, type=type_of(InputType), optional=false, repeated=false, wt=.Varint};
        wait_type := FieldDesc.{tag=30, type=type_of(WaitType), optional=false, repeated=false, wt=.Varint};
        timeout := FieldDesc.{tag=40, type=type_of(float64), optional=false, repeated=false, wt=.Fixed64};
    };

    encode :: (b: *[..]u8, self: Emc_Aux_Input_Wait) {
        #insert #run encode_code_writer(Emc_Aux_Input_Wait.{});
    }

    decode :: (b: []u8) -> Emc_Aux_Input_Wait {
        #insert #run decode_code_writer(Emc_Aux_Input_Wait.{});
    }

};
#insert #run setters_code_writer(Emc_Aux_Input_Wait.{});
Emc_Exec_Plugin_Ca1l :: struct {
    call: string;

    _desc_table :: struct {
        call := FieldDesc.{tag=20, type=type_of(string), optional=false, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Emc_Exec_Plugin_Ca1l) {
        #insert #run encode_code_writer(Emc_Exec_Plugin_Ca1l.{});
    }

    decode :: (b: []u8) -> Emc_Exec_Plugin_Ca1l {
        #insert #run decode_code_writer(Emc_Exec_Plugin_Ca1l.{});
    }

};
#insert #run setters_code_writer(Emc_Exec_Plugin_Ca1l.{});
Emc_Io_Plugin_Call :: struct {
    call: string;

    _desc_table :: struct {
        call := FieldDesc.{tag=20, type=type_of(string), optional=false, repeated=false, wt=.Size};
    };

    encode :: (b: *[..]u8, self: Emc_Io_Plugin_Call) {
        #insert #run encode_code_writer(Emc_Io_Plugin_Call.{});
    }

    decode :: (b: []u8) -> Emc_Io_Plugin_Call {
        #insert #run decode_code_writer(Emc_Io_Plugin_Call.{});
    }

};
#insert #run setters_code_writer(Emc_Io_Plugin_Call.{});
